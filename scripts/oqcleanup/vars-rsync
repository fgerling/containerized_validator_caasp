#!/usr/bin/perl -w
# Copyright (c) 2012-2014 SUSE Linux Products GmbH
# Copyright (c) 2015 SUSE Linux GmbH
# Copyright (c) 2016 SUSE LLC
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

=head1 rsync.pl

rsync.pl - script to sync iso images and repos for openqa

=head1 SYNOPSIS

rsync.pl [OPTIONS] [modules]

=head1 OPTIONS

=over 4

=item B<--host> HOST

openqa host. If not specified isos a are synced but not posted to openqa

=item B<--dry>

dry run, don't actually sync files

=item B<--add-existing>

normally isos that are already on disk are not posted again to openqa. This
option post them anyways.

=item B<--set> KEY=VALUE

pass additional settings that override values from job templates. TEST and
MACHINE are special. openQA will filter job templates according to that.

=item B<--iso> FILE

only sync specified FILE (if found)

=item B<--destdir> DIR

override default iso dir (/var/lib/openqa/factory/iso)

=item B<--repodir> DIR

override default repo dir (/var/lib/openqa/factory/repo)

=item B<--repourl> URL

URL to reach repos (default HOST/assets/repo, fallback http://openqa.opensuse.org/assets/repo)

=item B<--help, -h>

print help

=item B<--man>

show full help

=item B<--verbose>

verbose output

=back

=head1 DESCRIPTION

$ rsync.pl -v

$ rsync.pl -v --host localhost

$ rsync.pl --host localhost totoest

$ rsync.pl --host localhost totoest --iso openSUSE-FTT-NET-x86_64-Snapshot20140903-Media.iso

$ rsync.pl --host localhost totoest --iso openSUSE-FTT-NET-x86_64-Snapshot20140903-Media.iso --set TEST=textmode

=cut

BEGIN { unshift @INC, "/usr/share/openqa/lib"}

use strict;
use Data::Dump qw/dd pp/;
use Getopt::Long;
Getopt::Long::Configure("no_ignore_case", "gnu_compat");

use File::Basename qw/basename dirname/;
use File::Rsync;
use File::Temp qw/tempfile/;
use JSON;
use Mojo::URL;
use OpenQA::Client;
use Mojo::UserAgent;
use MIME::Base64 qw/encode_base64url/;

use feature "state";

my %options;

sub usage($) {
    my $r = shift;
    eval "use Pod::Usage;";
    if ($@) {
        die "cannot display help, install perl(Pod::Usage)\n";
    }
    pod2usage($r);
}

our $sle12_sp_in_staging = 'SP2';

if ($ENV{SLE12_SP}) {
  $sle12_sp_in_staging = $ENV{SLE12_SP};
}

GetOptions(
    \%options,
    "verbose|v",
    "destdir|d=s",
    "repodir=s",
    "host=s",
    "repourl=s",
    "set=s%",
    "iso=s" => sub { $options{iso}->{$_[1]} = 1 },
    "add-existing",
    "no-extract",
    "force",
    "dry",
    "man" => sub { usage({-verbose => 2, -exitval => 0})},
    "help|h",
) or usage(1);

#usage(1) unless @ARGV;
usage(0) if ($options{'help'});
my @todo = @ARGV;

$options{destdir} ||= '/var/lib/openqa/factory';
$options{repodir} ||= $options{destdir}.'/repo';

-o $options{destdir} || die "$options{destdir} is not owned by current user. This is probably not what you want (use '-f' otherwise)"
    unless $options{force};

my $backend_opensuse = 'rsync://openqa@obs-backend.publish.opensuse.org/opensuse-internal/build/';
my $backend_opensuse2 = 'rsync://openqa@obs-back-stage.publish.opensuse.org/opensuse-internal/build/';
my $opensuse_pattern = qr/^openSUSE-(?<version>[0-9.]+)-(?<arch>(?:i[56]86|x86_64|i586-x86_64|ppc64le|ppc64[-_]ppc64le|aarch64))-Build(?<build>\d+)$/;

my $openqa_url = Mojo::URL->new('http://openqa.opensuse.org');
my $client;

if ($options{host}) {
    if ($options{'host'} !~ '/') {
        $openqa_url = Mojo::URL->new();
        $openqa_url->host($options{'host'});
        $openqa_url->scheme('http');
    } else {
        $openqa_url = Mojo::URL->new($options{'host'});
    }
#    $client = OpenQA::Client->new(key => $options{'key'}, secret => $options{'secret'}, api => $openqa_url->host);
    $client = OpenQA::Client->new(apikey => '1586227F0D3D1841', apisecret => '447D40731D527EB4', api => $openqa_url->host);
}

my $scc_url = $openqa_url->clone()->host('scc.'.$openqa_url->host);

$options{repourl} ||= $openqa_url.'/assets/repo';

sub dryrun
{
    return $options{dry};
}

# return full path to save file as based on name
sub dirfor
{
    my ($name) = @_;
    my $type = 'hdd';
    if ($name =~ /\.iso$/) {
        $type = 'iso';
    }
    return join('/', $options{destdir}, $type, $name);
}

sub use_fake_scc($)
{
    my ($settings) = @_;
    return 1 if $settings->{VERSION} =~ /12-SP2/ || $settings->{VERSION} =~ /12-SP3/;
    return 0;
}

sub rename_stage
{
    my $name = shift;
    my $stage = shift;
    my $arch = shift || 'x86_64';
    my $name_suffix = shift // '';

    my $prj = 'Staging';
    if ($stage =~ s/:DVD$//) {
        $prj .= '2';
    }
    if ($name =~ /Test(?:-([^-]+))?-Build([^-]+)-Media.iso/) {
        $arch = $1 if $1;
        return sprintf("openSUSE$name_suffix-Staging:%s-%s-DVD-%s-Build%s-Media.iso", $stage, $prj, $arch, $2);
    }
}

sub rename_stage_42
{
    my $name = shift;
    my $stage = shift;
    my $prj = 'Staging';
    if ($stage =~ s/:DVD$//) {
        $prj .= '2';
    }
    if ($name =~ /Test-Build([^-]+)-Media.iso/) {
        return sprintf("openSUSE-Leap:42.2-Staging:%s-%s-DVD-x86_64-Build%s-Media.iso", $stage, $prj, $1);
    }
}

sub settings_stage_42
{
    my ($name, $version) = @_;
    my $prj = 'Staging';
    my $stage = $version;
    $stage =~ s,S:,,;
    if ($version =~ s/:DVD$//) {
        $prj .= '2';
    }
    my $renamed = rename_stage_42($name, $stage);
    if ($name =~ /Test-Build([^-]+)-Media.iso/) {
        return {
            DISTRI => 'opensuse',
            VERSION => $version,
            ARCH => 'x86_64',
            FLAVOR => $prj.'-DVD',
            BUILD => $1,
        };
    }
    return undef;
}


sub mirror_opensuse_factory
{
    my $settings = shift;
    # we need a http URL here - NET installs are HTTP only (we don't test SMB or FTP)
    $settings->{SUSEMIRROR} = $options{repourl}."/".$settings->{REPO_0};
    $settings->{MIRROR_HTTP} = $settings->{SUSEMIRROR};
    $settings->{FULLURL} = 1;
}

# Add Server-DVD installation mirrors for Server-MINI network installation
sub mirror_sles
{
    my $settings = shift;
    my $sles_path = sprintf "SLE-%s-Server-DVD-%s-Build%s-Media1",
        $settings->{VERSION},
        $settings->{ARCH},
        $settings->{BUILD};
    
    $settings->{MIRROR_HTTP} = "http://openqa.suse.de/assets/repo/$sles_path";
    $settings->{MIRROR_FTP}  = "ftp://openqa.suse.de/$sles_path";
    $settings->{MIRROR_NFS}  = "nfs://openqa.suse.de/var/lib/openqa/share/factory/repo/$sles_path";
}

sub latest_iso($$) {
   my ($path, $glob) = @_;

   my $rsync = File::Rsync->new(src => "$path/$glob", timeout => 3600);
   my $last;
   for my $name ($rsync->list) {
      chomp $name;
      $name =~ s/\\n$//;
      $name =~ s/.* //;
      $last = "$path/$name";
   }
   #warn "Can't find any of $path/$glob\n" unless $last;
   return $last;
}

sub extract_iso_as_repo {
    my ($file) = @_;
    # Extract iso
    my $iso_repodir = $options{repodir}."/".basename($file, '.iso');
    unless(-d $iso_repodir) {
        print "Extracting ".$file."\n" if $options{verbose};
        unless (dryrun || $options{'no-extract'}) {
            my $tmp = "$iso_repodir.new";
            mkdir $tmp;
            if (system("bsdtar", "xf", $file, "-C", $tmp) == 0) {
                rename $tmp, $iso_repodir;
            }
        }
    }
    return basename($iso_repodir);
}

sub sync_addons {
    my ($settings) = @_;

    for my $i (1..6) {
        my $key = "ISO_$i";
        my $src = $settings->{$key};
        if (!$src) {
            $key = "_$key";
            $src = $settings->{$key};
        }
        next unless $src;
        my $iso = basename($src);
        my $repo = basename($iso, '.iso');
        my $dest = dirfor($iso);
        if (! -e $dest) {
            print "syncing $dest\n" if $options{verbose};
            if (!dryrun) {
                my $rsync = File::Rsync->new(src => $src, timeout => 3600, dest => $dest);
                $rsync->exec or warn "rsync $src -> $dest failed";
            }
        }
        if (!use_fake_scc($settings)) {
            extract_iso_as_repo($dest);
        }
        if ($key =~ m/^_/) {
            # remove temporary ISO keys
            delete $settings->{$key};
            next;
        }
        $settings->{$key} = $iso;
        if (!use_fake_scc($settings)) {
            my $repokey = $key;
            $repokey =~ s,ISO_,REPO_,;
            warn "BUG: $repokey exists, will be overwritten with $repo!" if ($settings->{$repokey});
            $settings->{$repokey} = ensure_scc_valid_entry($repo);
        }
    }

    warn "BUG: REPO_0 exists, will be overwritten with ISO!" if ($settings->{REPO_0});
    $settings->{REPO_0} = extract_iso_as_repo(dirfor($settings->{ISO}));
}

sub current_sle11_addons($$)
{
    my ($path, $arch) = @_;
    my %settings;

    $settings{ISO_1} = latest_iso($path, "SLE-11-SP4-SDK-DVD-$arch-Build*-Media1.iso");
    $settings{ISO_2} = latest_iso($path, "SLE-HA-11-SP4-$arch-Build*-Media1.iso");

    # SMT addon. Will not be registered but used on SLE11-SP4. Hardcoded to
    # build 0008 on request of Marita.
    $settings{ISO_3} = "SLE-11-SMT-SP3-i586-s390x-x86_64-Build0008-Media1.iso";

    if ($arch eq 'x86_64' || $arch eq 's390x') {
      $settings{ISO_4} = latest_iso($path, "SLE-HA-GEO-11-SP4-s390x-x86_64-Build*-Media.iso");
    }

    return %settings;
}

# input:
# {
#   location => rsync path
#   targetname => name in $repodir
#   expect_buildid => (optional) buildid the repo must have
#   buildid_variable => (optional), which capture group from
#                       buildid_pattern to use for the build
#                       id, default 'build'
#   buildid_pattern => a regexp that is used to extract the build
#                      id from the media.1/build file. Must have at
#                      least one capture group that sets
#                      buildid_variable
sub _reposync
{
    my %args = @_;

    print "reposync $args{location}\n  -> $args{targetname}\n" if $options{verbose};

    unless ($args{location} && $args{targetname}) {
        dd \%args;
        warn "location or targetname missing";
        return 0;
    }

    my $rsync = File::Rsync->new(timeout => 3600);

    if ($args{expect_buildid}) {
        unless ($args{buildid_pattern}) {
            warn "buildid_pattern missing";
            return 0;
        }

        my ($fh, $tmp) = tempfile("reposync-XXXXXX", TMPDIR => 1);
        unless ($tmp) {
            warn "couldn't create tmp file: $!";
            return 0;
        }

        # read media.1/build to check if the correct repo is available
        $rsync->exec(src => $args{location}.'/media.1/build', dest => $tmp, inplace => 1);
        print $rsync->err if $rsync->err;

        unless ($rsync->status == 0) {
            warn "rsync failed";
            return 0
        }

        my $buildid = <$fh>;
        unless ($buildid) {
            warn "got empty buildid";
            return 0;
        }
        chomp $buildid;
        close $fh;
        unlink $tmp;

        unless ($buildid =~ $args{buildid_pattern}) {
            warn "invalid build id $buildid\n";
            return 0;
        }
        my $build = $+{$args{buildid_variable}//'build'};
        unless ($build eq $args{expect_buildid}) {
            print "build '$build' of repo '$buildid' doesn't match iso with build '$args{expect_buildid}'\n" if $options{verbose};
            return 0;
        }
    }

    my $dest = join('/', $options{repodir}, $args{targetname});
    if (-e $dest) {
        warn "$dest already exist, not syncing again!\n";
        return 1;
    }
    my $current = $dest;
    $current =~ s/(?:Build|Snapshot)[^-]+/CURRENT/;
    my $link = readlink($current);
    if ($link && $link !~ /^\//) {
        $link = join('/', $options{repodir}, $link);
    }

    printf "  syncing %s\n", $dest if $options{verbose};

    return 1 if dryrun;

    if (-e $dest.'.new') {
        print "    $dest.new exists, resuming previous sync ...";
    }
    my @rsync_args = (
            delete => 1,
            verbose => 0,
# some filter for debugging
#            filter => [
#                '+ /*',
#                '+ /media.1/**',
#                '+ /boot/**',
#                '+ /suse/setup/',
#                '+ /suse/setup/**',
#                '- *',
#            ],
            recursive => 1,
            links => 1,
            perms => 1,
            times => 1,
            specials => 1,
            ipv4 => 1,
            src => $args{location},
            dest => $dest.'.new/',
    );
    push @rsync_args, 'link-dest', [ $link ] if $link;
#    dd $args if $options{verbose};
    my $ret = $rsync->exec(@rsync_args);
    print $rsync->err if $rsync->err;
    print $rsync->out if $options{verbose};
    unless (defined $ret && $ret) {
        warn "rsync failed $ret\n";
        return 0;
    }
    unless(rename($dest.'.new', $dest)) {
        warn "couldn't rename $dest.new -> $dest: $!\n";
        return 0;
    }
    unlink($current);
    unless(symlink(basename($dest), $current)) {
        warn "symlink $dest: $!";
    }
    print "sync done\n" if $options{verbose};
    return 1;
}

# Separately create ha geo symlinks both for x86_64 and s390x
# pointing to synced ha geo s390x-x86_64 directories, see bsc#976795
sub add_ha_geo_symlink {
    my ($dest) = @_;
    return if ($dest !~ /HA-GEO-POOL-s390x-x86_64/);
    (my $ha_geo_x86_64 = $dest) =~ s/-s390x//;
    (my $ha_geo_s390x  = $dest) =~ s/-x86_64//;
    for my $link ($ha_geo_x86_64, $ha_geo_s390x) {
        symlink(basename($dest), $link) or die "couldn't create symlink $link to $dest: $!";
    }
}

# Server|Desktop -> SERVER|DESKTOP, see bsc#980867
sub ensure_scc_valid_entry
{
    my ($repo) = @_;
    return $repo =~ s/(Server|Desktop)/\U$1\E/r;
}

sub reposync_sle
{
    state $ret;
    return $ret if defined $ret;

    my ($settings) = @_;

    my $info = $settings->{'.addonsyncinfo'};
    for my $repo (keys %$info) {
        my $r = _reposync(location => $info->{$repo}->{url}.'/',
            targetname => ensure_scc_valid_entry($repo),
            expect_buildid => $info->{$repo}->{expect_buildid},
            buildid_pattern => $info->{$repo}->{buildid_pattern},
        );
        if ($info->{$repo}->{has_license}) {
            $r = _reposync(location => $info->{$repo}->{url}.'.license/',
                targetname => "$repo.license",
                expect_buildid => $info->{$repo}->{expect_buildid},
                buildid_pattern => $info->{$repo}->{buildid_pattern},
            );
        }
    }
    return $ret;
}

sub extract_build($) {
    my ($iso) = @_;
    return unless $iso;

    if ($iso =~ /-Build(.*)-/) {
        return $1;
    }
    return;
}

my %current_repos;

sub update_current_repo {
   my ($path, $repo, $build) = @_;
  
   # no need to sync twice during one rsync.pl run
   return $current_repos{$repo} if $current_repos{$repo};

   my $trepo = ensure_scc_valid_entry($repo);
   my $dpath = $options{repodir} . "/$trepo-CURRENT";
   my %rsync_args = (
            delete => 1,
            recursive => 1,
            links => 1,
            perms => 1,
            times => 1,
            specials => 1,
            ipv4 => 1,
            verbose => 1,
            src => "$path/$repo/",
            dest => "$dpath/",
    );
    my $rsync = File::Rsync->new(timeout => 3600);

    my $ret = $rsync->exec(\%rsync_args);
    print $rsync->err if $rsync->err;
    print $rsync->out if $options{verbose};
    unless (defined $ret && $ret) {
        warn "rsync failed $ret\n";
        return;
    }
    
    if (!$build && open(BUILD, "$dpath/media.1/build")) {
      $build = <BUILD>;
      chomp $build;
      $build = ensure_scc_valid_entry($build);
      close(BUILD);
    }
    if ($build) {
      $current_repos{$repo} = $build;
      my $target = $options{repodir} . "/$build";
      if ($repo =~ m/(-Media[^-]*)$/) {
        $target .= $1;
      }
      print "LINK AWAY $dpath -> $target\n" if $options{verbose};
      # using rsync here to keep hard links and make it more forgiven to
      # cancelled sync calls
      $rsync_args{src} = "$dpath/";
      $rsync_args{dest} = "$target/";
      $rsync_args{'link-dest'} = [ $dpath ];
      $ret = $rsync->exec(\%rsync_args);

      print $rsync->err if $rsync->err;
      print $rsync->out if $options{verbose};

      add_ha_geo_symlink($target);
    }
    return $build;
}

sub add_sle12_addons($)
{
    my ($settings) = @_;
    my $arch = $settings->{ARCH};

    my $path = "dist.suse.de::repos/SUSE:/SLE-12-SP2:/GA/images/iso/";

    $settings->{_ISO_1} = latest_iso($path, "SLE-12-SP2-SDK-DVD-$arch-Build*-Media1.iso");
    $settings->{BUILD_SDK} = extract_build($settings->{_ISO_1});
    $settings->{_ISO_2} = latest_iso($path, "SLE-12-SP2-HA-DVD-$arch-Build*-Media1.iso");
    $settings->{BUILD_HA} = extract_build($settings->{_ISO_2});

    if ($arch eq 'x86_64' || $arch eq 's390x') {
        $settings->{_ISO_3} = latest_iso($path, "SLE-12-SP2-HA-GEO-DVD-s390x-x86_64-Build*-Media.iso");
        $settings->{BUILD_HA_GEO} = extract_build($settings->{_ISO_3});
    }
    if ($arch eq 'x86_64') {
        $settings->{_ISO_5} = latest_iso($path, "SLE-12-SP2-RT-DVD-x86_64-Build*-Media1.iso");
        $settings->{BUILD_RT} = extract_build($settings->{_ISO_5});
        $settings->{_ISO_6} = latest_iso($path, "SLE-12-SP2-WE-DVD-x86_64-Build*-Media1.iso");
        $settings->{BUILD_WE} = extract_build($settings->{_ISO_6});
    }
    # if you add more, don't forget to update i down there

    if (use_fake_scc($settings)) {
        my $path = 'rsync://dist.suse.de/repos/SUSE:/SLE-12-SP2:/GA/images/repo';

        # list of repos to sync.
        # name: part of directory name on dist
        # scc:  identifier of the extension in the scc json file
        # repo: name of the pool repo
        # has_license: set to also rsync extra license directory
        # nonfree: set to also add regkey for that
        # mustmatch: which DVD flavor to sync this for. buildid of that repo must match repo of the DVD
        # medium: '1' is for binary RPMs (the default), '2' for source RPMs, and '3' for RPMs with debug information
        my @products = (
            { name => 'Server', scc => 'SLES', repo => 'SLES12-SP2-Pool', mustmatch => 'Server-DVD' },
            { name => 'Server', scc => 'SLES', repo => 'SLES12-SP2-Pool-Debug', mustmatch => 'Server-DVD', medium => 3 },
            { name => 'Desktop', scc => 'SLED', repo => 'SLED12-SP2-Pool', mustmatch => 'Desktop-DVD' },
            { name => 'SDK', scc => 'sle-sdk', repo => 'SLE-SDK12-SP2-Pool', has_license => 1 },
            { name => 'HA', scc => 'sle-ha', repo => 'SLE-HA12-SP2-Pool', has_license => 1, nonfree => 1, archs => [ qw/ppc64le s390x x86_64/ ] },
            { name => 'HA-GEO', scc => 'sle-ha-geo', repo => 'SLE-HA-GEO12-SP2-Pool', has_license => 1, nonfree => 1, archs => { x86_64 => 's390x-x86_64', s390x => 's390x-x86_64'} },
            #{ name => 'Live-Patching', scc => 'sle-live-patching', repo => 'SLE-Live-Patching12-Pool', nonfree => 1 },
            { name => 'WE', scc => 'sle-we', repo => 'SLE-WE12-SP2-Pool', has_license => 1, nonfree => 1, archs => [ qw/x86_64/ ] },
            { name => 'RT', scc => 'sle-rt', repo => 'SLE-RT12-SP2-Pool', has_license => 1, nonfree => 1, archs => [ qw/x86_64/ ] },
        );
        my $info;
        my $i = 7; # start one higher than last iso, to retain potential ISO_x -> REPO_x mapping
        for my $p (@products) {
            if ($p->{mustmatch}) {
                next unless $p->{mustmatch} eq $settings->{FLAVOR};
            }
            my $name   = $p->{name};
            my $medium = 1;
            if ($p->{medium}) {
                $medium = $p->{medium};
            }
            my $poolarch = $arch;
            if ($p->{archs}) {
		if (ref($p->{archs}) eq 'ARRAY') {
			next unless grep { $arch eq $_ } @{$p->{archs}};
	        } else {
			$poolarch = $p->{archs}->{$arch};
			next unless $poolarch;
	        }
            }
            my $build = update_current_repo($path, "SLE-12-SP2-$name-POOL-$poolarch-Media$medium");
            if ($build && $p->{has_license}) {
               update_current_repo($path, "SLE-12-SP2-$name-POOL-$poolarch-Media$medium.license", $build);
            }
            my $url = latest_iso($path, "SLE-12-SP2-$name-POOL-$poolarch-Build*-Media$medium");
            next unless $url;
            my $base = basename($url);
            #store some information for reposync_sle 
            $info->{$base} = {
                url => $url,
                %{$p},
            };
            if ($p->{mustmatch}) {
                $info->{$base}->{expect_buildid} = $settings->{BUILD};
                $info->{$base}->{buildid_pattern} = qr/^SLE-12-SP2-(?<flavor>(?:Server|Desktop)-POOL)-(?<arch>[^-]+)-Build(?<build>[^-]+)/;
            }
            my $exported_repo_name  = $p->{repo};
            $exported_repo_name     =~ s/\d+-SP\d-Pool//;
            $exported_repo_name     =~ s/-/_/g;
            my $scc_valid_base      = ensure_scc_valid_entry($base);
            $settings->{uc "REPO_$exported_repo_name"} = $scc_valid_base;
            $settings->{"REPO_$i"} = $scc_valid_base;
            ++$i;
            if ($p->{has_license}) {
                $settings->{"REPO_$i"} = $scc_valid_base.'.license';
                ++$i;
            }
        }
        $settings->{'.addonsyncinfo'} = $info;
    }
}

# only used for sle11
sub split_ha {
    my $settings = shift;
    my @ret = ($settings);
    if ($settings->{ISO_2}) {
        # clone
        my %newha = %$settings;
        if ($settings->{ISO_2} =~ m/SLE-HA-.*-Build(.*)-Media1/) {
            $newha{BUILD} = $1 . "@" . $settings->{BUILD};
            $newha{VERSION} = "11-SP4-HA";
            push(@ret, \%newha);
        }
    }
    return @ret;
}

sub compute_register_sle12 {
    my $settings = shift;
    my @ret = ($settings);
    # split out HA & RT as it should have a different build number in a
    # new job group
    if ($settings->{FLAVOR} eq 'Server-DVD' && $settings->{BUILD_HA}) {
        # clone HA
        my %newha = %$settings;
        $newha{BUILD} = $settings->{BUILD_HA} . "@" . $settings->{BUILD_SLE};
        $newha{FLAVOR} = "Server-DVD-HA";
        push(@ret, \%newha);
    }
    if ($settings->{FLAVOR} eq 'Server-DVD' && $settings->{BUILD_RT}) {
        # clone RT
        my %newrt = %$settings;
        $newrt{BUILD} = $settings->{BUILD_RT} . "@" . $settings->{BUILD_SLE};
        $newrt{FLAVOR} = "Server-DVD-RT";
        push(@ret, \%newrt);
    }
    return @ret;
}

sub settings_stage
{
    my ($name, $version, $arch) = @_;
    $arch //= 'x86_64';
    my $prj = 'Staging';
    my $stage = $version;
    $stage =~ s,Staging:,,;
    if ($version =~ s/:DVD$//) {
        $prj .= '2';
    }
    my $renamed = rename_stage($name, $stage, undef, ':42');
    if ($name =~ /Test(?:-([^-]+))?-Build([^-]+)-Media.iso/) {
        $arch = $1 if $1;
        return {
            DISTRI => 'opensuse',
            VERSION => $version,
            ARCH => $arch,
            FLAVOR => $prj.'-DVD',
            BUILD => $2,
        };
    }
    return undef;
}

sub settings_factory
{
    my ($file, $version) = @_;
    return undef unless ($file =~ /^openSUSE-(?:Factory|Tumbleweed|13\.2|Leap-42\.[12])-(?<flavor>.+?)-(?<arch>(?:i[56]86|x86_64|i586-x86_64|ppc64|ppc64le|aarch64))-(?:Snapshot|Build)(?<build>[^-]+)-Media\.iso$/);
    my $renamed = $file;
    return {
        DISTRI => 'opensuse',
        VERSION => $version,
        FLAVOR => $+{flavor},
        ARCH => $+{arch},
        BUILD => $+{build},
    };
}

sub settings_casp {
    my ($file) = @_;
    my $settings = {
        DISTRI => 'CASP',
        VERSION => '1.0'
    };

    # SUSE-CASP-1.0-DVD-x86_64-Build0025-Media1.iso
    # SUSE-CASP-1.0.x86_64-1.0.0-Build8.2.qcow2
    if ($file =~ /^SUSE-CASP-(?<version>[^-]+)-DVD-(?<arch>[^-]+)-Build(?<build>[^-]+)-Media1.iso/) {
        $settings->{FLAVOR} = 'DVD';
    } elsif ($file =~ /^SUSE-CASP-1.0.(?<arch>[^-]+)-(?<kiwiversion>[^-]+)-Build(?<build>[^-]+).qcow2/) {
        $settings->{FLAVOR} = 'VMX';
        $settings->{ISO} = '';
        $settings->{HDD_1}  = $file;
        $settings->{HDD_2}  = 'SUSE-CASP-cloud-config.img';
        $settings->{NUMDISKS} = 2;
    } else {
        return undef;
    }
    $settings->{ARCH} = $+{arch};
    $settings->{BUILD}  = $+{build};

    return $settings;
}

sub settings_jeos
{
    my ($file) = @_;
    return undef unless
    ($file =~ /^openSUSE-Leap-(?<version>[^-]+)-(?<flavor>JeOS-for-(?:kvm-and-xen|MS-HyperV|OpenStack-Cloud|VMware|XEN))\.(?<arch>[^-]+)-(?<version>[^-]+)-Build(?<build>[^-]+)\.qcow2/);
    return {
        DISTRI => 'opensuse',
        VERSION => $+{version},
        FLAVOR => $+{flavor},
        ARCH => $+{arch},
        BUILD => $+{build},
        ISO => '',
        HDD_1 => $file,
    };
}

sub settings_vmdp
{
    my ($file, $version) = @_;
    return undef unless ($file =~ /^(?:VMDP-WIN|vmdp)-(?<build>.*?)_(?:vblk|virtio).iso$/);
    return {
        DISTRI => 'vmdp',
        VERSION => $version,
        FLAVOR => 'standard',
        ARCH => 'x86_64',
        BUILD => $+{build},
        ISO => '', # will be removed later
        ISO_1 => $file,
        ADDONS => 1,
    };
}

sub add_repo_factory
{
    my $settings = shift;
    return undef unless $settings;
    my $arch = $settings->{ARCH};
    if ($arch eq 'x86_64' || $arch =~ /^i\d86$/) {
        $arch = 'i586-x86_64'
    }
    elsif ($arch eq 'ppc64' || $arch eq 'ppc64le') {
        $arch = 'ppc64_ppc64le';
    }
    $settings->{REPO_0} = sprintf "openSUSE-%s-oss-$arch-Snapshot%s", $settings->{VERSION}, $settings->{BUILD};
    mirror_opensuse_factory($settings),
    return $settings;
}

# a wrapper so we don't try repo rsync for every iso
sub reposync_tumblewed
{
    state $ret;
    return $ret if defined $ret;

    my ($settings) = @_;

    my $location;
    if ($settings->{ARCH} =~ /ppc64/) {
        $location = "$backend_opensuse/openSUSE:Factory:PowerPC:ToTest/images/local/_product:openSUSE-ftp-ftp-ppc64_ppc64le/openSUSE-*-ppc64-ppc64le-Media1/",
    }
    elsif ($settings->{ARCH} eq 'aarch64') {
        $location = "$backend_opensuse/openSUSE:Factory:ARM:ToTest/images/local/_product:openSUSE-ftp-ftp-aarch64/openSUSE-*-aarch64-Media1/",
    }
    else {
        $location = "$backend_opensuse/openSUSE:Factory:ToTest/images/local/_product:openSUSE-ftp-ftp-i586_x86_64/openSUSE-*-i586-x86_64-Media1/";
    }

    $ret = _reposync(
        location => $location,
        targetname => $settings->{REPO_0},
        expect_buildid => $settings->{BUILD},
        buildid_variable => 'version',
        buildid_pattern => $opensuse_pattern,
    );

    return $ret;
}

# a wrapper so we don't try repo rsync for every iso
sub reposync_leap
{
    state $ret;

    my ($settings) = @_;

    my $version = $settings->{VERSION};

    my $location;
    if ($settings->{ARCH} =~ /ppc64/) {
        $location = "$backend_opensuse/openSUSE:Leap:$version:Ports/images_ppc/local/_product:openSUSE-ftp-ftp-ppc64le/openSUSE-*-Media1/";
    }
    elsif ($settings->{ARCH} eq 'aarch64') {
        $location = "$backend_opensuse/openSUSE:Leap:$version:Ports/images_arm/local/_product:openSUSE-ftp-ftp-aarch64/openSUSE-*-Media1/";
    }
    else {
        $location = "$backend_opensuse/openSUSE:Leap:$version/images/local/_product:openSUSE-ftp-ftp-x86_64/openSUSE-*-Media1/";
    }

    return $ret->{$location} if defined $ret->{$location};

    $ret->{$location} = _reposync(
        location => $location,
        targetname => $settings->{REPO_0},
        expect_buildid => $settings->{BUILD},
        buildid_pattern => $opensuse_pattern,
    );

    return $ret->{$location};
}

sub save_changelogs
{
    my ($filename, $settings) = @_;
    use FindBin;
    my $script = $FindBin::Bin.'/factory-package-news.py';
    return unless -x $script;
    return unless $settings->{FLAVOR} eq 'DVD' && $settings->{ARCH} eq 'x86_64';
    my @cmd = ($script,
        'save',
        '--dir',
        "/var/lib/openqa/factory/snapshot-changes",
        '--snapshot',
        $settings->{BUILD}, $filename);
    dd \@cmd if $options{'verbose'};
    system(@cmd);
}

sub register_staging_s390
{
   my ($settings) = @_;
   $settings->{REPO_0} = extract_iso_as_repo(dirfor($settings->{ISO}));
}

# rsync configuration
# identifier => {
#
## enable/disable. 1 to disable entry
#     skip => INTEGER
#
## rsync base url
#     path => STRING
#
## rsync include/exclude patterns, see rsync manpage
#     filter => [ STRING, ...]
#
## function to rename iso image (optional). First parameter original
## file new, second parameter full rsync path.
#     rename => CODE
#
## function to get setting for image. First parameter original
## file new, second parameter full rsync path. Expected to return hash ref
#     settings => CODE|HASH
#
## function to sync repository. First parameter is settings
##    reposync => CODE
# }
my $config = {
    dvd => {
        skip => 1,
        path => "$backend_opensuse/openSUSE:Factory/images/local/",
        filter => [
            '+ /_product:*',
            '+ /_product:*/*Media*/',
            '- *Addon*',
            '- *-NET-*', # exclude NET for now as it's rebuild too often
#                       '- *-Live-*', # exclude Live for now as it's rebuild too often
            '+ **/*.iso',
            '- *' ],
        settings => sub { settings_factory(shift, 'Factory'); },
#        repo => [ qw/oss/ ],
    },
    staging_core => { # re-use name to avoid having to adjust iso parser
        skip => 0,
        path =>  "$backend_opensuse2/openSUSE:Factory:Rings:1-MinimalX/images/",
        filter => [ '+ /ppc64le', '+ /x86_64', '+ /i586', '+ /*/Test-DVD-*', '+ *.iso', '- *' ],
        rename => sub { rename_stage(shift, 'Core')},
        settings => sub { settings_stage(shift, 'Core')},
    },
    staging_testdvd => {
        skip => 0,
        path =>  "$backend_opensuse2/openSUSE:Factory:Rings:2-TestDVD/images/",
        filter => [ '+ /ppc64le', '+ /x86_64', '+ /i586', '+ /*/Test-*', '+ *.iso', '- *' ],
        rename => sub { rename_stage(shift, 'Core:DVD')},
        settings => sub { settings_stage(shift, 'Core:DVD')},
    },
    '42_core' => {
        skip => 0,
        path =>  "$backend_opensuse2/openSUSE:Leap:42.2:Rings:1-MinimalX/images/",
        filter => [ '+ /ppc64le', '+ /x86_64', '+ /i586', '+ /*/Test-DVD-*', '+ *.iso', '- *' ],
        rename => sub { rename_stage(shift, 'Core', undef, ':42')},
        settings => sub { settings_stage(shift, '42:Core')},
    },
    '42_testdvd' => {
        skip => 0,
        path =>  "$backend_opensuse2/openSUSE:Leap:42.2:Rings:2-TestDVD/images/",
        filter => [ '+ /ppc64le', '+ /x86_64', '+ /i586', '+ /*/Test-*', '+ *.iso', '- *' ],
        rename => sub { rename_stage(shift, 'Core:DVD', undef, ':42')},
        settings => sub { settings_stage(shift, '42:Core:DVD')},
    },
    sle11 => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-11-SP4:/GA/images/iso/",
        sync_addons => \&sync_addons,
        compute_register => \&split_ha,
        filter => [
            '+ SLED-11-SP4-DVD-i586-*-Media1.iso',
            '+ SLED-11-SP4-DVD-x86_64-*-Media1.iso',
            '+ SLES-11-SP4-DVD-i586-*-Media1.iso',
            '+ SLES-11-SP4-DVD-x86_64-*-Media1.iso',
            '+ SLES-11-SP4-DVD-ppc64-*-Media1.iso',
            '+ SLES-11-SP4-DVD-s390x-*-Media1.iso',
            '- *' ],
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^SLE(?<flavor>[SD])-11-SP4-DVD-(?<arch>[^-]+)-Build(?<build>[^-]+)-/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => '11-SP4-Alpha',
                    FLAVOR => { 'S' => 'Server-DVD', 'D' => 'Desktop-DVD' }->{$+{flavor}},
                    ARCH => $+{arch},
                    BUILD => $+{build},
                    current_sle11_addons("dist.suse.de::repos/SUSE:/SLE-11-SP4:/GA/images/iso/", $+{arch}),
                };
            }
            # Add-on isos, don't register them. They will be picked up by the
            # main isos.
            if ($fn =~ /^SLE-/) {
               return { '_dont_register' => 1 };
            }
            return undef;
        },
    },
    sle12_arm => {
        skip => 1,
        path => "dist.suse.de::repos/Devel:/ARM:/SLE-12:/GA/images/iso/",
        filter => [
            '+ SLE-12-Server-DVD-*-Media1.iso',
            '- *' ],
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^SLE-12-(Server-DVD)-([^-]+)-Build([^-]+)-/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => '12',
                    FLAVOR => $1,
                    ARCH => $2,
                    BUILD => $3,
                };
            }
            return undef;
        },
    },
    sle12 => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12-SP2:/GA/images/iso/",
        sync_addons => \&sync_addons,
        compute_register => \&compute_register_sle12,
        filter => [
            '+ SLE-12-SP2-Server-DVD-x86_64-*-Media1.iso',
            '+ SLE-12-SP2-Desktop-DVD-x86_64-*-Media1.iso',
            '+ SLE-12-SP2-SAP-DVD-x86_64-*-Media1.iso',
            '+ SLE-12-SP2-SAP-DVD-ppc64le-*-Media1.iso',
            '+ SLE-12-SP2-Server-DVD-ppc64le-*-Media1.iso',
            '+ SLE-12-SP2-Server-DVD-s390x-*-Media1.iso',
            '+ SLE-12-SP2-Server-DVD-aarch64-*-Media1.iso',
            '+ SLE-12-SP2-Server-MINI-ISO-x86_64-*-Media.iso',
            # use http repo instead
            #'+ SLE-12-WE-DVD-x86_64-*-Media?.iso',
            '- *' ],
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^SLE-12-SP2-(?<flavor>(?:Server|Desktop|SAP)-(DVD|MINI-ISO))-(?<arch>[^-]+)-Build(?<build>[^-]+)-/) {
                my $settings = {
                    DISTRI => 'SLE',
                    VERSION => '12-SP2',
                    FLAVOR => $+{flavor},
                    ARCH => $+{arch},
                    BUILD => $+{build},
                    BUILD_SLE => $+{build},
                };
                add_sle12_addons($settings);
                mirror_sles($settings) if ($settings->{FLAVOR} eq 'Server-MINI-ISO');
                return $settings;
            }
            return undef;
        },
        reposync => \&reposync_sle,
    },
    casp_dvd => {
        skip => 1,
        path => "dist.suse.de::repos/Devel:/CASP:/1.0/images/iso/",
        filter => [
            '+ SUSE-CASP-1.0-DVD-x86_64-*-Media1.iso',
            '- *' ],
        settings => \&settings_casp,
    },
    casp_vmx => {
        skip => 1,
        path => "dist.suse.de::repos/Devel:/CASP:/1.0:/VMX/images/",
        filter => [
            '+ SUSE-CASP-1.0.x86_64-*.qcow2',
            '- *' ],
        settings => \&settings_casp,
    },
    sle12_jeos => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12:/Update:/JeOS/images/",
        filter => [
            '+ SLES12-JeOS-for-kvm-and-xen.x86_64-*.qcow2',
            '- *' ],
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^SLES12-(?<flavor>JeOS-for-(?:kvm-and-xen|MS-HyperV|OpenStack-Cloud|VMware|XEN))\.(?<arch>[^-]+)-(?<version>[^-]+)-Build(?<build>[^-]+)\.qcow2/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => '12',
                    FLAVOR => $+{flavor},
                    ARCH => $+{arch},
                    BUILD => $+{build},
                    ISO => '',
                    HDD_1 => $fn,
                    #current_sle12_addons("dist.suse.de::repos/SUSE:/SLE-12-SP1:/GA/images/iso/", $+{arch}),
                };
            }
            return undef;
        },
    },
    sle12_sp1_jeos => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12-SP1:/Update:/JeOS/images/",
        filter => [
            '+ SLES12-SP1-JeOS-for-kvm-and-xen.x86_64-*.qcow2',
            '+ SLES12-SP1-JeOS-for-XEN.x86_64-*.qcow2',
            '+ SLES12-SP1-JeOS-for-VMware.x86_64-*.vmdk',
            '- *' ],
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^SLES(?<version>12-SP1)-(?<flavor>JeOS-for-(?:kvm-and-xen|MS-HyperV|OpenStack-Cloud|VMware|XEN))\.(?<arch>[^-]+)-(?<version>[^-]+)-Build(?<build>[^-]+)\.(?:qcow2|vmdk|vhdfixed\.xz)/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => $+{version},
                    FLAVOR => $+{flavor},
                    ARCH => $+{arch},
                    BUILD => $+{build},
                    ISO => '',
                    HDD_1 => $fn,
                };
            }
            return undef;
        },
    },
    sle12_staging => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12-$sle12_sp_in_staging:/GA:/Staging:/",
        filter => [
            '+ /*',
            '+ /*/images',
            '+ /*/images/iso',
            '+ /*/images/iso/Test-Server-DVD-x86_64-*-Media.iso',
            # use http repo instead
            #'+ SLE-12-WE-DVD-x86_64-*-Media?.iso',
            # not bootable
            #'+ SLE-12-HA-DVD-x86_64-*-Media1.iso',
            '- *' ],
        rename => sub {
            my $name = $_[0];
            if ($_[1] =~ m,^([[:alnum:]]+)/,) {
               my $letter = $1;
               $name = "SLE12-$sle12_sp_in_staging-Staging:$letter-$name";
            }
            return $name;
        },

        settings => sub {
            my ($fn, $path) = @_;
            $path =~ s,/.*,,;
            if ($fn =~ /^Test-Server-DVD-([^-]+)-Build([^-]+)-/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => "12-$sle12_sp_in_staging",
                    FLAVOR => "Server-DVD-Staging:$path",
                    ARCH => $1,
                    BUILD => $2
                };
            }
            return undef;
        },
    },
    sle12_staging_s390 => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12-$sle12_sp_in_staging:/GA:/Staging:/S390:/",
        filter => [
            '+ /*',
            '+ /*/images',
            '+ /*/images/iso',
            '+ /*/images/iso/Test-Server-DVD-s390x-*-Media.iso',
            # use http repo instead
            #'+ SLE-12-WE-DVD-x86_64-*-Media?.iso',
            # not bootable
            #'+ SLE-12-HA-DVD-x86_64-*-Media1.iso',
            '- *' ],
        rename => sub {
            my $name = $_[0];
            if ($_[1] =~ m,^([[:alnum:]]+)/,) {
               my $letter = $1;
               # the s390 repo needs special treatment
	       $name =~ s,-Test-Server-DVD,,;
	       $name =~ s,-Media,,;
               $name = "SLE12-$sle12_sp_in_staging-Staging-$letter-$name";
            }
            return $name;
        },
        sync_addons => \&register_staging_s390,
        settings => sub {
            my ($fn, $path) = @_;
            $path =~ s,/.*,,;
            if ($fn =~ /^Test-Server-DVD-([^-]+)-Build([^-]+)-/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => "12-$sle12_sp_in_staging",
                    FLAVOR => "Server-DVD-Staging:$path",
                    ARCH => $1,
                    BUILD => $2
                };
            }
            return undef;
        },
    },
    sle12_core => {
        skip => 1,
        path => "dist.suse.de::repos/SUSE:/SLE-12:/Rings:/1-MinimalX/images/iso/",
        filter => [
            '+ *.iso',
            '- *' ],
        rename => sub {
            my $name = shift;
            if ($name =~ /Test-Build([^-]+)-Media.iso/) {
                return sprintf("SLE-12-Core-DVD-x86_64-Build%s-Media.iso", $1);
            }
        },
        settings => sub {
            my $fn = shift;
            if ($fn =~ /^Test-Build([^-]+)/) {
                return {
                    DISTRI => 'SLE',
                    VERSION => '12',
                    FLAVOR => 'Core-DVD',
                    ARCH => 'x86_64',
                    BUILD => $1,
                };
            }
            return undef;
        },
    },
    staging => {
        skip => 0,
        path => $backend_opensuse2,
        filter => [
            '+ /openSUSE:Factory:Staging:*',
            '+ /openSUSE:Factory:Staging:*/images',
            '+ /openSUSE:Factory:Staging:*/images/x86_64',
            '+ /openSUSE:Factory:Staging:*/images/x86_64/Test-DVD-x86_64',
            '+ /openSUSE:Factory:Staging:*/images/x86_64/Test-DVD-ppc64le',
            '+ *.iso',
            '- *',
        ],
        rename => sub {
            $_[1] =~ /^openSUSE:Factory:Staging:([[:alnum:]:]*)\//;
            rename_stage($_[0], $1);
        },
        settings => sub {
            $_[1] =~ /^openSUSE:Factory:Staging:([[:alnum:]:]*)\//;
            settings_stage($_[0], "Staging:$1");
        },
    },
    tumbleweed_arm => {
        skip => 0,
        path => "$backend_opensuse/openSUSE:Factory:ARM:ToTest/images/",
        filter => [
            '+ /*',
            '+ /local/_product:*',
            '+ **/*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, 'Tumbleweed') ); },
        # arm doesn't have snapshot version yet
        reposync => \&reposync_tumblewed,
    },
    tumbleweed_ppc64 => {
        skip => 0,
        path => "$backend_opensuse/openSUSE:Factory:PowerPC:ToTest/images/",
        filter => [
            '+ /*',
            '+ /local/_product:*ppc64*',
            '+ **/*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, 'Tumbleweed') ); },
#        repo => { ttoss => 'oss' },
        reposync => \&reposync_tumblewed,
    },
    tumbleweed => {
        skip => 0,
        path => "$backend_opensuse/openSUSE:Factory:ToTest/images/",
        filter => [
            '+ /*',
            '+ /*/kiwi-image-livecd-*',
            '+ /local/_product:*',
            '+ **/*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, 'Tumbleweed') ); },
#        repo => { ttoss => 'oss' },
        notify => \&save_changelogs,
        reposync => \&reposync_tumblewed,
    },
    '42_arm' => {
        skip => 0,
        path => "$backend_opensuse/openSUSE:Leap:42.2:Ports/images_arm/",
        filter => [
            '+ /*',
            '+ /local/_product:*aarch64*',
            '+ **/*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, '42.2') ); },
        reposync => \&reposync_leap,
    },
    42 => {
        skip => 0,
        path => "$backend_opensuse/openSUSE:Leap:42.2/images/",
        filter => [
            '+ /*',
            '+ /local/_product:*',
            '+ **/*-DVD-*.iso',
            '+ **/*-NET-*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, '42.2') ); },
#        repo => { ttoss => 'oss' },
        reposync => \&reposync_leap,
    },
    leap_421_jeos => {
        skip => 1,
        path => "$backend_opensuse/openSUSE:Leap:42.1:Images/images/",
        filter => [
            '+ /x86_64/',
            '+ /x86_64/:repo/',
            '+ */openSUSE-Leap-42.1-JeOS-for-kvm-and-xen.x86_64-*.qcow2',
            '- *' ],
        settings => \&settings_jeos,
    },
    '42_ports' => {
        skip => 1,
        path => "$backend_opensuse/openSUSE:Leap:42.2:Ports/",
        filter => [
            '+ /images_*',
            '+ /images_*/local',
            '+ /images_*/local/_product:*',
            '+ **/*-DVD-*.iso',
            '+ **/*-NET-*.iso',
            '- *' ],
        settings => sub { add_repo_factory( settings_factory(shift, '42.2') ); },
        reposync => \&reposync_leap,
    },
    vmdp_stable => {
        skip => 1,
        path => 'xen100.virt.lab.novell.com::VMDP/release/',
        filter => [
            '+ /*',
            '+ VMDP-WIN*.iso',
            '- *',
            ],
            settings => sub { settings_vmdp(shift, 'stable'); },
    },
    vmdp_testing => {
        skip => 1,
        path => 'xen100.virt.lab.novell.com::VMDP/testing/current/',
        filter => [
            '+ *.iso',
            '- *',
            ],
            settings => sub { settings_vmdp(shift, 'testing'); },
    },
    staging_42 => {
        skip => 0,
        path => $backend_opensuse2,
        filter => [
            '+ /openSUSE:Leap:42.2:Staging:*',
            '+ /openSUSE:Leap:42.2:Staging:*/images',
            '+ /openSUSE:Leap:42.2:Staging:*/images/x86_64',
            '+ /openSUSE:Leap:42.2:Staging:*/images/x86_64/Test-DVD-x86_64',
            '+ *.iso',
            '- *',
        ],
        rename => sub {
            $_[1] =~ /^openSUSE:Leap:42.2:Staging:([[:alnum:]:]*)\//;
            rename_stage_42($_[0], $1);
        },
        settings => sub {
            $_[1] =~ /^openSUSE:Leap:42.2:Staging:([[:alnum:]:]*)\//;
            settings_stage_42($_[0], "42:S:$1");
        },
    },
};

@todo = grep { ! $config->{$_}->{skip}//0 } keys %$config unless @todo;

my @tosync;
for my $flavor (@todo) {
    unless ($config->{$flavor}) {
        warn "$flavor does not exist!\n";
        next;
    }
    print "$flavor\n" if $options{verbose};
    my $path = $config->{$flavor}->{path};
    my $rsync = File::Rsync->new(src => $path, recursive=>1, filter => $config->{$flavor}->{filter}, timeout => 3600);
    my @rlist = $rsync->list;

SYNCLIST:
    for my $name (@rlist) {
        chomp $name;
        $name =~ s/\\n$//;
        $name =~ s/.* //;
        # XXX: This is the top-most 'guardian' for media filename extensions
        next unless $name =~ /\.(?:iso|qcow2|vmdk|vhdfixed\.xz)$/;
        my $newname = basename($name);
        unless ($config->{$flavor}->{settings}) {
            warn "settings not defined for $name!";
            next;
        }
        if ( $name =~ /SLE-12-$sle12_sp_in_staging-Server-MINI-ISO-x86_64-Build(\d+)-Media.iso/ ) {
            my $dvd = "SLE-12-$sle12_sp_in_staging-Server-DVD-x86_64-Build$1-Media1";
            unless ( -d $options{repodir} .'/'. $dvd || grep( /$dvd/, @rlist ) ) {
                warn "Skipping SLES-MINI, DVD mirror is not ready!\n";
                next;
            }
        }
        my $settings = $config->{$flavor}->{settings};
        if (ref $settings eq 'CODE') {
            $settings = &$settings($newname, $name);
        }
        unless ($settings && ref $settings eq 'HASH') {
            warn "settings for $name is neither hash nor sub!\n";
            next;
        }
        if ($options{set}) {
            @{$settings}{keys %{$options{set}}} = values %{$options{set}};
        }

        if ($config->{$flavor}->{rename}) {
            $newname = $config->{$flavor}->{rename}($newname, $name);
            unless ($newname) {
                print STDERR "ERROR: empty new name for $name, skipped.\n";
                next;
            }
        }

        next if (exists $options{iso} && ! $options{iso}->{$newname});

        if (!defined $settings->{ISO}) {
                $settings->{ISO} = $newname;
        } elsif (!$settings->{ISO}) {
                # XXX special hack introduced for VMDP. Remove iso setting if
                # it's empty. This allows for the job templates to set the ISO.
                delete $settings->{ISO};
        }

        my $path = $path.$name;

        if (-e dirfor($newname)) {
            unless ($options{"add-existing"}) {
                print STDERR "$newname exists, skipped\n" if $options{verbose};;
                next;
            }
        }

        for my $repo (sort grep { /^REPO_\d+$/ } keys %$settings) {
            $repo = basename($settings->{$repo});
            my $repodir = join('/', $options{repodir}, $repo);

            if (! -e $repodir) {
                if ($config->{$flavor}->{reposync}) {
                    $config->{$flavor}->{reposync}($settings);
                }
                unless (dryrun || -e $repodir) {
                    print STDERR "$newname: repo $repo missing, skipped\n";;
                    next SYNCLIST;
                }
            }
        }

        my $syncdata = {
            src => $path,
            dest => $newname,
            settings => $settings
        };
        for my $i (qw/notify sync_addons compute_register/) {
            if ($config->{$flavor}->{$i}) {
                $syncdata->{$i} = $config->{$flavor}->{$i};
            }
        }
        push @tosync, $syncdata;
    }

    if ($rsync->err) {
        print STDERR "+++ Rsync errors:\n";
        print STDERR join("", $rsync->err);
    }
}

{
    my @toregister;
    my $rsync = File::Rsync->new;
    while (my $cfg = shift @tosync) {
        print "  $cfg->{src}\n  -> $cfg->{dest}...\n" if $options{verbose};
        #
        my $dest = $cfg->{dest};

        my $link;
        if ( $dest =~ /(?:Build|Snapshot)[^-]+/ ) {
            $link = $dest;
            $dest =~ s/(?:Build|Snapshot)[^-]+/CURRENT/;
        }
        my $success;
        unless (dryrun || -e dirfor($link||$dest)) {
            $rsync->exec(checksum => 1, verbose=>1, src => $cfg->{src}, dest => dirfor($dest));
            print $rsync->err if $rsync->err;
            print $rsync->out if $options{verbose};
            $success = $rsync->status == 0;
        } else {
            $success = 1;
        }
        if ($success) {
            if (!dryrun && $link) {
                $link = dirfor($link);
                if (-e $link) {
                    # XXX: checksum and do nothing?
                    unlink $link;
                }
                link(dirfor($dest), $link) || warn "link: $!";
            }
            if ($cfg->{notify}) {
                $cfg->{notify}($link?$link:dirfor($dest), $cfg->{settings});
            }
            if ($cfg->{sync_addons}) {
                $cfg->{sync_addons}($cfg->{settings});
            }

            if ($cfg->{settings}->{_dont_register}) {
                print "not registering $cfg->{dest}\n" if $options{verbose};
            } else {
                # Save iso info for api registration
                my $settings = {%{$cfg->{settings}}};

		# clean up undefined settings - and leave empty ones
		for my $key (keys %$settings) {
		    if (!defined $settings->{$key}) {
			delete $settings->{$key};
		    }
		}

                if ($cfg->{compute_register}) {
                    push @toregister, $cfg->{compute_register}($settings);
                } else {
                    push @toregister, $settings;
                }
            }
        }
    }

    print "registering ...\n" if $options{verbose} && @toregister;

    # Register isos
    while (my $isoinfo = shift @toregister) {

        if (dryrun || $options{verbose}) {
            print to_json ($isoinfo, { pretty => 1, canonical => 1});
            next if dryrun;
        }

        my $fn = sprintf "%s.%d.json", dirfor($isoinfo->{ISO}//$isoinfo->{HDD_1}), scalar @toregister;
        if (open my $fh, '>', $fn) {
            print $fh to_json ($isoinfo, { pretty => 1, canonical => 1});
            close $fh;
        }

        next unless $client;

        my $ua_url = $openqa_url->clone();
        $ua_url->path("/api/v1/isos");
        $ua_url->query($isoinfo);
        while(1) {
            my $res = $client->post($ua_url)->res;
            if (($res->code//0) != 200) {
                print STDERR "error scheduling $isoinfo->{ISO}\n";
                if ($res->code) {
                    print STDERR $res->code." ".$res->message."\n";
                    if ($res->body) {
                        print STDERR pp($res->json || $res->body);
                    }
                    # abort unless server side error
                    last unless $res->is_status_class(500);
                }
                print STDERR "retry in 60s ...\n";
                sleep 60;
                next;
            }
            if ($res->body && $options{verbose}) {
                dd($res->json || $res->body);
            }
            last;
        }
    }
}

# vim: sw=4 et
